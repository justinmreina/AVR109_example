
AVR109_example.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  000006fa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000006a6  00007000  00007000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  000006fa  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000072c  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000060  00000000  00000000  0000076c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000105a  00000000  00000000  000007cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000a84  00000000  00000000  00001826  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000844  00000000  00000000  000022aa  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000134  00000000  00000000  00002af0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000508  00000000  00000000  00002c24  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000068e  00000000  00000000  0000312c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000b8  00000000  00000000  000037ba  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
    7000:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__ctors_end>
    7004:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7008:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    700c:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7010:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7014:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7018:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    701c:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7020:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7024:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7028:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    702c:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7030:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7034:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7038:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    703c:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7040:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7044:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7048:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    704c:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7050:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7054:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7058:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    705c:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7060:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7064:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7068:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    706c:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7070:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7074:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7078:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    707c:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7080:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7084:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7088:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    708c:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7090:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7094:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    7098:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    709c:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    70a0:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    70a4:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    70a8:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    70ac:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>
    70b0:	0c 94 64 38 	jmp	0x70c8	; 0x70c8 <__bad_interrupt>

000070b4 <__ctors_end>:
    70b4:	11 24       	eor	r1, r1
    70b6:	1f be       	out	0x3f, r1	; 63
    70b8:	cf ef       	ldi	r28, 0xFF	; 255
    70ba:	d8 e0       	ldi	r29, 0x08	; 8
    70bc:	de bf       	out	0x3e, r29	; 62
    70be:	cd bf       	out	0x3d, r28	; 61
    70c0:	0e 94 3c 39 	call	0x7278	; 0x7278 <main>
    70c4:	0c 94 51 3b 	jmp	0x76a2	; 0x76a2 <_exit>

000070c8 <__bad_interrupt>:
    70c8:	0c 94 00 38 	jmp	0x7000	; 0x7000 <__vectors>

000070cc <BlockLoad>:
/**	@fcn		unsigned char BlockLoad(unsigned int size, unsigned char mem, ADDR_T *address)
 *  @brief		x
 *  @details	x
 */
/************************************************************************************************************************************/
unsigned char BlockLoad(unsigned int size, unsigned char mem, ADDR_T *address) {
    70cc:	9f 92       	push	r9
    70ce:	af 92       	push	r10
    70d0:	bf 92       	push	r11
    70d2:	cf 92       	push	r12
    70d4:	df 92       	push	r13
    70d6:	ef 92       	push	r14
    70d8:	ff 92       	push	r15
    70da:	0f 93       	push	r16
    70dc:	1f 93       	push	r17
    70de:	cf 93       	push	r28
    70e0:	df 93       	push	r29
    70e2:	cd b7       	in	r28, 0x3d	; 61
    70e4:	de b7       	in	r29, 0x3e	; 62
    70e6:	c0 58       	subi	r28, 0x80	; 128
    70e8:	d1 09       	sbc	r29, r1
    70ea:	0f b6       	in	r0, 0x3f	; 63
    70ec:	f8 94       	cli
    70ee:	de bf       	out	0x3e, r29	; 62
    70f0:	0f be       	out	0x3f, r0	; 63
    70f2:	cd bf       	out	0x3d, r28	; 61
    70f4:	6c 01       	movw	r12, r24
    70f6:	8a 01       	movw	r16, r20
    unsigned char buffer[BLOCKSIZE];
    unsigned int data;
    ADDR_T tempaddress;
	
    // EEPROM memory type.
    if(mem=='E') {
    70f8:	65 34       	cpi	r22, 0x45	; 69
    70fa:	a1 f5       	brne	.+104    	; 0x7164 <BlockLoad+0x98>

        /* Fill buffer first, as EEPROM is too slow to copy with UART speed */
        for(tempaddress=0;tempaddress<size;tempaddress++)
    70fc:	89 2b       	or	r24, r25
    70fe:	71 f0       	breq	.+28     	; 0x711c <BlockLoad+0x50>
    7100:	ce 01       	movw	r24, r28
    7102:	01 96       	adiw	r24, 0x01	; 1
    7104:	7c 01       	movw	r14, r24
    7106:	5c 01       	movw	r10, r24
    7108:	ac 0c       	add	r10, r12
    710a:	bd 1c       	adc	r11, r13
            buffer[tempaddress] = recchar();
    710c:	0e 94 49 3b 	call	0x7692	; 0x7692 <recchar>
    7110:	d7 01       	movw	r26, r14
    7112:	8d 93       	st	X+, r24
    7114:	7d 01       	movw	r14, r26
	
    // EEPROM memory type.
    if(mem=='E') {

        /* Fill buffer first, as EEPROM is too slow to copy with UART speed */
        for(tempaddress=0;tempaddress<size;tempaddress++)
    7116:	aa 16       	cp	r10, r26
    7118:	bb 06       	cpc	r11, r27
    711a:	c1 f7       	brne	.-16     	; 0x710c <BlockLoad+0x40>
            buffer[tempaddress] = recchar();
        
        /* Then program the EEPROM */
        _WAIT_FOR_SPM();
    711c:	07 b6       	in	r0, 0x37	; 55
    711e:	00 fc       	sbrc	r0, 0
    7120:	fd cf       	rjmp	.-6      	; 0x711c <BlockLoad+0x50>
    	for( tempaddress=0; tempaddress < size; tempaddress++) {
    7122:	c1 14       	cp	r12, r1
    7124:	d1 04       	cpc	r13, r1
    7126:	09 f4       	brne	.+2      	; 0x712a <BlockLoad+0x5e>
    7128:	54 c0       	rjmp	.+168    	; 0x71d2 <BlockLoad+0x106>
    712a:	fe 01       	movw	r30, r28
    712c:	31 96       	adiw	r30, 0x01	; 1
    712e:	9f 01       	movw	r18, r30
    7130:	2c 0d       	add	r18, r12
    7132:	3d 1d       	adc	r19, r13
	        EEARL = *address;												// Setup EEPROM address
    7134:	d8 01       	movw	r26, r16
    7136:	8c 91       	ld	r24, X
    7138:	81 bd       	out	0x21, r24	; 33
            EEARH = ((*address) >> 8);
    713a:	11 96       	adiw	r26, 0x01	; 1
    713c:	8c 91       	ld	r24, X
    713e:	82 bd       	out	0x22, r24	; 34
            EEDR = buffer[tempaddress];										// Get byte.
    7140:	81 91       	ld	r24, Z+
    7142:	80 bd       	out	0x20, r24	; 32
            EECR |= (1<<EEMPE);												// Write byte.
    7144:	fa 9a       	sbi	0x1f, 2	; 31
            EECR |= (1<<EEPE);
    7146:	f9 9a       	sbi	0x1f, 1	; 31
            while (EECR & (1<<EEPE))										// Wait for write operation to finish.
    7148:	f9 99       	sbic	0x1f, 1	; 31
    714a:	fe cf       	rjmp	.-4      	; 0x7148 <BlockLoad+0x7c>
                ;

  			(*address)++;													// Select next EEPROM byte
    714c:	d8 01       	movw	r26, r16
    714e:	8d 91       	ld	r24, X+
    7150:	9c 91       	ld	r25, X
    7152:	11 97       	sbiw	r26, 0x01	; 1
    7154:	01 96       	adiw	r24, 0x01	; 1
    7156:	8d 93       	st	X+, r24
    7158:	9c 93       	st	X, r25
        for(tempaddress=0;tempaddress<size;tempaddress++)
            buffer[tempaddress] = recchar();
        
        /* Then program the EEPROM */
        _WAIT_FOR_SPM();
    	for( tempaddress=0; tempaddress < size; tempaddress++) {
    715a:	2e 17       	cp	r18, r30
    715c:	3f 07       	cpc	r19, r31
    715e:	51 f7       	brne	.-44     	; 0x7134 <BlockLoad+0x68>
                ;

  			(*address)++;													// Select next EEPROM byte
        }

        return '\r';														// Report programming OK
    7160:	8d e0       	ldi	r24, 0x0D	; 13
    7162:	3a c0       	rjmp	.+116    	; 0x71d8 <BlockLoad+0x10c>
    } 
    
    // Flash memory type.
	else if(mem=='F') {														// NOTE: For flash programming, 'address' is given in words.
    7164:	66 34       	cpi	r22, 0x46	; 70
    7166:	09 f0       	breq	.+2      	; 0x716a <BlockLoad+0x9e>
    7168:	36 c0       	rjmp	.+108    	; 0x71d6 <BlockLoad+0x10a>
        (*address) <<= 1;													// Convert address to bytes temporarily.
    716a:	fa 01       	movw	r30, r20
    716c:	a0 80       	ld	r10, Z
    716e:	b1 80       	ldd	r11, Z+1	; 0x01
    7170:	aa 0c       	add	r10, r10
    7172:	bb 1c       	adc	r11, r11
    7174:	b1 82       	std	Z+1, r11	; 0x01
    7176:	a0 82       	st	Z, r10
        tempaddress = (*address);											// Store address in page.
	
        do {
            data = recchar();
            data |= (recchar() << 8);
            _FILL_TEMP_WORD(*address,data);
    7178:	99 24       	eor	r9, r9
    717a:	93 94       	inc	r9
	else if(mem=='F') {														// NOTE: For flash programming, 'address' is given in words.
        (*address) <<= 1;													// Convert address to bytes temporarily.
        tempaddress = (*address);											// Store address in page.
	
        do {
            data = recchar();
    717c:	0e 94 49 3b 	call	0x7692	; 0x7692 <recchar>
    7180:	e8 2e       	mov	r14, r24
    7182:	f1 2c       	mov	r15, r1
            data |= (recchar() << 8);
    7184:	0e 94 49 3b 	call	0x7692	; 0x7692 <recchar>
            _FILL_TEMP_WORD(*address,data);
    7188:	d8 01       	movw	r26, r16
    718a:	ed 91       	ld	r30, X+
    718c:	fc 91       	ld	r31, X
    718e:	f8 2a       	or	r15, r24
    7190:	07 01       	movw	r0, r14
    7192:	90 92 57 00 	sts	0x0057, r9	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7196:	e8 95       	spm
    7198:	11 24       	eor	r1, r1
            (*address)+=2;													// Select next word in memory.
    719a:	cf 01       	movw	r24, r30
    719c:	02 96       	adiw	r24, 0x02	; 2
    719e:	f8 01       	movw	r30, r16
    71a0:	91 83       	std	Z+1, r25	; 0x01
    71a2:	80 83       	st	Z, r24
            size -= 2;														// Reduce number of bytes to write by two.
    71a4:	f2 e0       	ldi	r31, 0x02	; 2
    71a6:	cf 1a       	sub	r12, r31
    71a8:	d1 08       	sbc	r13, r1
        } while(size);														// Loop until all bytes written.
    71aa:	41 f7       	brne	.-48     	; 0x717c <BlockLoad+0xb0>

	_PAGE_WRITE(tempaddress);
    71ac:	25 e0       	ldi	r18, 0x05	; 5
    71ae:	f5 01       	movw	r30, r10
    71b0:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    71b4:	e8 95       	spm
	_WAIT_FOR_SPM();
    71b6:	07 b6       	in	r0, 0x37	; 55
    71b8:	00 fc       	sbrc	r0, 0
    71ba:	fd cf       	rjmp	.-6      	; 0x71b6 <BlockLoad+0xea>
	_ENABLE_RWW_SECTION();
    71bc:	21 e1       	ldi	r18, 0x11	; 17
    71be:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    71c2:	e8 95       	spm

        (*address) >>= 1;													// Convert address back to Flash words again.
    71c4:	96 95       	lsr	r25
    71c6:	87 95       	ror	r24
    71c8:	d8 01       	movw	r26, r16
    71ca:	8d 93       	st	X+, r24
    71cc:	9c 93       	st	X, r25
        return '\r';														// Report programming OK
    71ce:	8d e0       	ldi	r24, 0x0D	; 13
    71d0:	03 c0       	rjmp	.+6      	; 0x71d8 <BlockLoad+0x10c>
                ;

  			(*address)++;													// Select next EEPROM byte
        }

        return '\r';														// Report programming OK
    71d2:	8d e0       	ldi	r24, 0x0D	; 13
    71d4:	01 c0       	rjmp	.+2      	; 0x71d8 <BlockLoad+0x10c>
        return '\r';														// Report programming OK
    }
    
    // Invalid memory type?
    else {
        return '?';
    71d6:	8f e3       	ldi	r24, 0x3F	; 63
    }
}
    71d8:	c0 58       	subi	r28, 0x80	; 128
    71da:	df 4f       	sbci	r29, 0xFF	; 255
    71dc:	0f b6       	in	r0, 0x3f	; 63
    71de:	f8 94       	cli
    71e0:	de bf       	out	0x3e, r29	; 62
    71e2:	0f be       	out	0x3f, r0	; 63
    71e4:	cd bf       	out	0x3d, r28	; 61
    71e6:	df 91       	pop	r29
    71e8:	cf 91       	pop	r28
    71ea:	1f 91       	pop	r17
    71ec:	0f 91       	pop	r16
    71ee:	ff 90       	pop	r15
    71f0:	ef 90       	pop	r14
    71f2:	df 90       	pop	r13
    71f4:	cf 90       	pop	r12
    71f6:	bf 90       	pop	r11
    71f8:	af 90       	pop	r10
    71fa:	9f 90       	pop	r9
    71fc:	08 95       	ret

000071fe <BlockRead>:
/**	@fcn		void BlockRead(unsigned int size, unsigned char mem, ADDR_T *address)
 *  @brief		x
 *  @details	x
 */
/************************************************************************************************************************************/
void BlockRead(unsigned int size, unsigned char mem, ADDR_T *address) {
    71fe:	0f 93       	push	r16
    7200:	1f 93       	push	r17
    7202:	cf 93       	push	r28
    7204:	df 93       	push	r29
    7206:	8c 01       	movw	r16, r24
    7208:	ea 01       	movw	r28, r20

    // EEPROM memory type.
    if (mem=='E') {															// Read EEPROM
    720a:	65 34       	cpi	r22, 0x45	; 69
    720c:	89 f4       	brne	.+34     	; 0x7230 <BlockRead+0x32>
        do {
            EEARL = *address;												// Setup EEPROM address
    720e:	88 81       	ld	r24, Y
    7210:	81 bd       	out	0x21, r24	; 33
            EEARH = ((*address) >> 8);
    7212:	89 81       	ldd	r24, Y+1	; 0x01
    7214:	82 bd       	out	0x22, r24	; 34
            (*address)++;													// Select next EEPROM byte
    7216:	88 81       	ld	r24, Y
    7218:	99 81       	ldd	r25, Y+1	; 0x01
    721a:	01 96       	adiw	r24, 0x01	; 1
    721c:	99 83       	std	Y+1, r25	; 0x01
    721e:	88 83       	st	Y, r24
            EECR |= (1<<EERE);												// Read EEPROM
    7220:	f8 9a       	sbi	0x1f, 0	; 31
            sendchar(EEDR);													// Transmit EEPROM dat ato PC
    7222:	80 b5       	in	r24, 0x20	; 32
    7224:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>

            size--;															// Decrease number of bytes to read
    7228:	01 50       	subi	r16, 0x01	; 1
    722a:	11 09       	sbc	r17, r1
        } while (size);														// Repeat until all block has been read
    722c:	81 f7       	brne	.-32     	; 0x720e <BlockRead+0x10>
    722e:	1f c0       	rjmp	.+62     	; 0x726e <BlockRead+0x70>
    }
    
    // Flash memory type.
	else if(mem=='F') {
    7230:	66 34       	cpi	r22, 0x46	; 70
    7232:	e9 f4       	brne	.+58     	; 0x726e <BlockRead+0x70>
        (*address) <<= 1;													// Convert address to bytes temporarily.
    7234:	88 81       	ld	r24, Y
    7236:	99 81       	ldd	r25, Y+1	; 0x01
    7238:	88 0f       	add	r24, r24
    723a:	99 1f       	adc	r25, r25
    723c:	99 83       	std	Y+1, r25	; 0x01
    723e:	88 83       	st	Y, r24
	
        do {
            sendchar( _LOAD_PROGRAM_MEMORY(*address) );
    7240:	e8 81       	ld	r30, Y
    7242:	f9 81       	ldd	r31, Y+1	; 0x01
    7244:	84 91       	lpm	r24, Z
    7246:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
            sendchar( _LOAD_PROGRAM_MEMORY((*address)+1) );
    724a:	e8 81       	ld	r30, Y
    724c:	f9 81       	ldd	r31, Y+1	; 0x01
    724e:	31 96       	adiw	r30, 0x01	; 1
    7250:	84 91       	lpm	r24, Z
    7252:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
            (*address) += 2;												// Select next word in memory.
    7256:	88 81       	ld	r24, Y
    7258:	99 81       	ldd	r25, Y+1	; 0x01
    725a:	02 96       	adiw	r24, 0x02	; 2
    725c:	99 83       	std	Y+1, r25	; 0x01
    725e:	88 83       	st	Y, r24
            size -= 2;														// Subtract two bytes from number of bytes to read
    7260:	02 50       	subi	r16, 0x02	; 2
    7262:	11 09       	sbc	r17, r1
        } while (size);														// Repeat until all block has been read
    7264:	69 f7       	brne	.-38     	; 0x7240 <BlockRead+0x42>

        (*address) >>= 1;													// Convert address back to Flash words again.
    7266:	96 95       	lsr	r25
    7268:	87 95       	ror	r24
    726a:	99 83       	std	Y+1, r25	; 0x01
    726c:	88 83       	st	Y, r24
    }
}
    726e:	df 91       	pop	r29
    7270:	cf 91       	pop	r28
    7272:	1f 91       	pop	r17
    7274:	0f 91       	pop	r16
    7276:	08 95       	ret

00007278 <main>:
/**	@fcn		int main(void)
 *  @brief		x
 *  @details	x
 */
/************************************************************************************************************************************/
int main(void) {
    7278:	4f 92       	push	r4
    727a:	5f 92       	push	r5
    727c:	6f 92       	push	r6
    727e:	7f 92       	push	r7
    7280:	8f 92       	push	r8
    7282:	9f 92       	push	r9
    7284:	af 92       	push	r10
    7286:	bf 92       	push	r11
    7288:	cf 92       	push	r12
    728a:	df 92       	push	r13
    728c:	ef 92       	push	r14
    728e:	ff 92       	push	r15
    7290:	0f 93       	push	r16
    7292:	1f 93       	push	r17
    7294:	cf 93       	push	r28
    7296:	df 93       	push	r29
    7298:	00 d0       	rcall	.+0      	; 0x729a <main+0x22>
    729a:	00 d0       	rcall	.+0      	; 0x729c <main+0x24>
    729c:	cd b7       	in	r28, 0x3d	; 61
    729e:	de b7       	in	r29, 0x3e	; 62
	//Locals
    ADDR_T address;
    volatile unsigned int temp_int;
    unsigned char val;

	DDRD = (1<<PIND1);
    72a0:	82 e0       	ldi	r24, 0x02	; 2
    72a2:	8a b9       	out	0x0a, r24	; 10
    /* Initialization */    
    void (*funcptr)(void) = 0x0000;											// Set up function pointer to RESET vector.
    
    initbootuart();															// Initialize UART.
    72a4:	0e 94 35 3b 	call	0x766a	; 0x766a <initbootuart>

    /* Branch to bootloader or application code? */
    if( !(PROGPIN & (1<<PROG_NO)) ) {										// If PROGPIN is pulled low, enter programmingmode.
    72a8:	1f 99       	sbic	0x03, 7	; 3
    72aa:	be c1       	rjmp	.+892    	; 0x7628 <main+0x3b0>
            // Read program memory.
            else if(val=='R')
            {        
                // Send high byte, then low byte of flash word.
                _WAIT_FOR_SPM();        
                _ENABLE_RWW_SECTION();
    72ac:	0f 2e       	mov	r0, r31
    72ae:	f1 e1       	ldi	r31, 0x11	; 17
    72b0:	df 2e       	mov	r13, r31
    72b2:	f0 2d       	mov	r31, r0

#ifndef REMOVE_FUSE_AND_LOCK_BIT_SUPPORT
            // Write lockbits.
            else if(val=='l') {
                _WAIT_FOR_SPM();        
                _SET_LOCK_BITS( recchar() ); // Read and set lock bits.
    72b4:	0f 2e       	mov	r0, r31
    72b6:	f9 e0       	ldi	r31, 0x09	; 9
    72b8:	ef 2e       	mov	r14, r31
    72ba:	f0 2d       	mov	r31, r0

#if defined(_GET_LOCK_BITS)
            // Read lock bits.
            else if(val=='r') {
                _WAIT_FOR_SPM();        
                sendchar( _GET_LOCK_BITS() );
    72bc:	44 24       	eor	r4, r4
    72be:	43 94       	inc	r4
    72c0:	51 2c       	mov	r5, r1


            // Read fuse bits.
            else if(val=='F') {
                _WAIT_FOR_SPM();        
                sendchar( _GET_LOW_FUSES() );
    72c2:	00 e0       	ldi	r16, 0x00	; 0
    72c4:	10 e0       	ldi	r17, 0x00	; 0


            // Read high fuse bits.
            else if(val=='N') {
                _WAIT_FOR_SPM();        
                sendchar( _GET_HIGH_FUSES() );
    72c6:	0f 2e       	mov	r0, r31
    72c8:	f3 e0       	ldi	r31, 0x03	; 3
    72ca:	6f 2e       	mov	r6, r31
    72cc:	71 2c       	mov	r7, r1
    72ce:	f0 2d       	mov	r31, r0


            // Read extended fuse bits.
            else if(val=='Q') {
                _WAIT_FOR_SPM();        
                sendchar( _GET_EXTENDED_FUSES() );
    72d0:	68 94       	set
    72d2:	88 24       	eor	r8, r8
    72d4:	81 f8       	bld	r8, 1
    72d6:	91 2c       	mov	r9, r1
            else if(val== 'm') {
                if(address >= (APP_END>>1)) {								// Protect bootloader area.
                    sendchar('?');
                } else {
                    _WAIT_FOR_SPM();        
                    _PAGE_WRITE( address << 1 ); // Convert word-address to byte-address and write.
    72d8:	0f 2e       	mov	r0, r31
    72da:	f5 e0       	ldi	r31, 0x05	; 5
    72dc:	af 2e       	mov	r10, r31
    72de:	f0 2d       	mov	r31, r0
            
            // Write program memory, high byte.
            else if(val=='C') {
                temp_int |= (recchar()<<8); // Get and insert high byte.
                _WAIT_FOR_SPM();
                _FILL_TEMP_WORD( (address << 1), temp_int ); // Convert word-address to byte-address and fill.
    72e0:	bb 24       	eor	r11, r11
    72e2:	b3 94       	inc	r11
            
            // Chip erase.
            else if(val=='e') {
                for(address = 0; address < APP_END;address += PAGESIZE) { // NOTE: Here we use address as a byte-address, not word-address, for convenience.
                    _WAIT_FOR_SPM();        
                    _PAGE_ERASE( address );
    72e4:	0f 2e       	mov	r0, r31
    72e6:	f3 e0       	ldi	r31, 0x03	; 3
    72e8:	ff 2e       	mov	r15, r31
    72ea:	f0 2d       	mov	r31, r0
    /* Branch to bootloader or application code? */
    if( !(PROGPIN & (1<<PROG_NO)) ) {										// If PROGPIN is pulled low, enter programmingmode.
        /* Main loop */
		//txtstr((uint8_t*)"Bootloader\n");
        for(;;) {
            val=recchar();													// Wait for command character.
    72ec:	0e 94 49 3b 	call	0x7692	; 0x7692 <recchar>

            // Check autoincrement status.
            if(val=='a') {
    72f0:	81 36       	cpi	r24, 0x61	; 97
    72f2:	21 f4       	brne	.+8      	; 0x72fc <main+0x84>
                sendchar('Y');												// Yes, we do autoincrement.
    72f4:	89 e5       	ldi	r24, 0x59	; 89
    72f6:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    72fa:	f8 cf       	rjmp	.-16     	; 0x72ec <main+0x74>
            }

            // Set address.
            else if(val=='A') {												// Set address... Flash addresses are given in words, not bytes.                                            
    72fc:	81 34       	cpi	r24, 0x41	; 65
    72fe:	81 f4       	brne	.+32     	; 0x7320 <main+0xa8>
                address=(recchar()<<8) | recchar();							// Read address high and low byte.
    7300:	0e 94 49 3b 	call	0x7692	; 0x7692 <recchar>
    7304:	c8 2e       	mov	r12, r24
    7306:	0e 94 49 3b 	call	0x7692	; 0x7692 <recchar>
    730a:	2c 2d       	mov	r18, r12
    730c:	30 e0       	ldi	r19, 0x00	; 0
    730e:	32 2f       	mov	r19, r18
    7310:	22 27       	eor	r18, r18
    7312:	28 2b       	or	r18, r24
    7314:	3a 83       	std	Y+2, r19	; 0x02
    7316:	29 83       	std	Y+1, r18	; 0x01
                sendchar('\r');												// Send OK back.
    7318:	8d e0       	ldi	r24, 0x0D	; 13
    731a:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    731e:	e6 cf       	rjmp	.-52     	; 0x72ec <main+0x74>
            }

            
            // Chip erase.
            else if(val=='e') {
    7320:	85 36       	cpi	r24, 0x65	; 101
    7322:	b1 f4       	brne	.+44     	; 0x7350 <main+0xd8>
                for(address = 0; address < APP_END;address += PAGESIZE) { // NOTE: Here we use address as a byte-address, not word-address, for convenience.
    7324:	1a 83       	std	Y+2, r17	; 0x02
    7326:	09 83       	std	Y+1, r16	; 0x01
    7328:	e0 e0       	ldi	r30, 0x00	; 0
    732a:	f0 e0       	ldi	r31, 0x00	; 0
                    _WAIT_FOR_SPM();        
    732c:	07 b6       	in	r0, 0x37	; 55
    732e:	00 fc       	sbrc	r0, 0
    7330:	fd cf       	rjmp	.-6      	; 0x732c <main+0xb4>
                    _PAGE_ERASE( address );
    7332:	f0 92 57 00 	sts	0x0057, r15	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7336:	e8 95       	spm
            }

            
            // Chip erase.
            else if(val=='e') {
                for(address = 0; address < APP_END;address += PAGESIZE) { // NOTE: Here we use address as a byte-address, not word-address, for convenience.
    7338:	e0 58       	subi	r30, 0x80	; 128
    733a:	ff 4f       	sbci	r31, 0xFF	; 255
    733c:	fa 83       	std	Y+2, r31	; 0x02
    733e:	e9 83       	std	Y+1, r30	; 0x01
    7340:	e1 15       	cp	r30, r1
    7342:	20 e7       	ldi	r18, 0x70	; 112
    7344:	f2 07       	cpc	r31, r18
    7346:	91 f7       	brne	.-28     	; 0x732c <main+0xb4>
                    _WAIT_FOR_SPM();        
                    _PAGE_ERASE( address );
                }
                sendchar('\r');												// Send OK back.
    7348:	8d e0       	ldi	r24, 0x0D	; 13
    734a:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    734e:	ce cf       	rjmp	.-100    	; 0x72ec <main+0x74>
            }
            
#ifndef REMOVE_BLOCK_SUPPORT
            // Check block load support.
            else if(val=='b') {
    7350:	82 36       	cpi	r24, 0x62	; 98
    7352:	51 f4       	brne	.+20     	; 0x7368 <main+0xf0>
    			sendchar('Y');												// Report block load supported.
    7354:	89 e5       	ldi	r24, 0x59	; 89
    7356:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    			sendchar((BLOCKSIZE>>8) & 0xFF);							// MSB first.
    735a:	80 e0       	ldi	r24, 0x00	; 0
    735c:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    			sendchar(BLOCKSIZE&0xFF);									// Report BLOCKSIZE (bytes).
    7360:	80 e8       	ldi	r24, 0x80	; 128
    7362:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    7366:	c2 cf       	rjmp	.-124    	; 0x72ec <main+0x74>
    		}


            // Start block load.
    		else if(val=='B') {
    7368:	82 34       	cpi	r24, 0x42	; 66
    736a:	c9 f4       	brne	.+50     	; 0x739e <main+0x126>
	    	    temp_int = (recchar()<<8) | recchar();						// Get block size.
    736c:	0e 94 49 3b 	call	0x7692	; 0x7692 <recchar>
    7370:	c8 2e       	mov	r12, r24
    7372:	0e 94 49 3b 	call	0x7692	; 0x7692 <recchar>
    7376:	2c 2d       	mov	r18, r12
    7378:	30 e0       	ldi	r19, 0x00	; 0
    737a:	32 2f       	mov	r19, r18
    737c:	22 27       	eor	r18, r18
    737e:	28 2b       	or	r18, r24
    7380:	3c 83       	std	Y+4, r19	; 0x04
    7382:	2b 83       	std	Y+3, r18	; 0x03
		    	val = recchar();											// Get memtype.
    7384:	0e 94 49 3b 	call	0x7692	; 0x7692 <recchar>
    7388:	68 2f       	mov	r22, r24
			    sendchar( BlockLoad(temp_int,val,&address) );				// Block load.
    738a:	8b 81       	ldd	r24, Y+3	; 0x03
    738c:	9c 81       	ldd	r25, Y+4	; 0x04
    738e:	ae 01       	movw	r20, r28
    7390:	4f 5f       	subi	r20, 0xFF	; 255
    7392:	5f 4f       	sbci	r21, 0xFF	; 255
    7394:	0e 94 66 38 	call	0x70cc	; 0x70cc <BlockLoad>
    7398:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    739c:	a7 cf       	rjmp	.-178    	; 0x72ec <main+0x74>
		    }
		
		    
		    // Start block read.
    		else if(val=='g') {
    739e:	87 36       	cpi	r24, 0x67	; 103
    73a0:	b9 f4       	brne	.+46     	; 0x73d0 <main+0x158>
	    	    temp_int = (recchar()<<8) | recchar();						// Get block size.
    73a2:	0e 94 49 3b 	call	0x7692	; 0x7692 <recchar>
    73a6:	c8 2e       	mov	r12, r24
    73a8:	0e 94 49 3b 	call	0x7692	; 0x7692 <recchar>
    73ac:	2c 2d       	mov	r18, r12
    73ae:	30 e0       	ldi	r19, 0x00	; 0
    73b0:	32 2f       	mov	r19, r18
    73b2:	22 27       	eor	r18, r18
    73b4:	28 2b       	or	r18, r24
    73b6:	3c 83       	std	Y+4, r19	; 0x04
    73b8:	2b 83       	std	Y+3, r18	; 0x03
    			val = recchar();											// Get memtype
    73ba:	0e 94 49 3b 	call	0x7692	; 0x7692 <recchar>
    73be:	68 2f       	mov	r22, r24
	    		BlockRead(temp_int,val,&address);							// Block read
    73c0:	8b 81       	ldd	r24, Y+3	; 0x03
    73c2:	9c 81       	ldd	r25, Y+4	; 0x04
    73c4:	ae 01       	movw	r20, r28
    73c6:	4f 5f       	subi	r20, 0xFF	; 255
    73c8:	5f 4f       	sbci	r21, 0xFF	; 255
    73ca:	0e 94 ff 38 	call	0x71fe	; 0x71fe <BlockRead>
    73ce:	8e cf       	rjmp	.-228    	; 0x72ec <main+0x74>
    		}		
#endif /* REMOVE_BLOCK_SUPPORT */

#ifndef REMOVE_FLASH_BYTE_SUPPORT            
            // Read program memory.
            else if(val=='R')
    73d0:	82 35       	cpi	r24, 0x52	; 82
    73d2:	d9 f4       	brne	.+54     	; 0x740a <main+0x192>
            {        
                // Send high byte, then low byte of flash word.
                _WAIT_FOR_SPM();        
    73d4:	07 b6       	in	r0, 0x37	; 55
    73d6:	00 fc       	sbrc	r0, 0
    73d8:	fd cf       	rjmp	.-6      	; 0x73d4 <main+0x15c>
                _ENABLE_RWW_SECTION();
    73da:	d0 92 57 00 	sts	0x0057, r13	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    73de:	e8 95       	spm
                sendchar(_LOAD_PROGRAM_MEMORY((address << 1)+1));
    73e0:	e9 81       	ldd	r30, Y+1	; 0x01
    73e2:	fa 81       	ldd	r31, Y+2	; 0x02
    73e4:	ee 0f       	add	r30, r30
    73e6:	ff 1f       	adc	r31, r31
    73e8:	31 96       	adiw	r30, 0x01	; 1
    73ea:	84 91       	lpm	r24, Z
    73ec:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
                sendchar(_LOAD_PROGRAM_MEMORY((address << 1)+0));
    73f0:	e9 81       	ldd	r30, Y+1	; 0x01
    73f2:	fa 81       	ldd	r31, Y+2	; 0x02
    73f4:	ee 0f       	add	r30, r30
    73f6:	ff 1f       	adc	r31, r31
    73f8:	84 91       	lpm	r24, Z
    73fa:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
                address++; // Auto-advance to next Flash word.
    73fe:	89 81       	ldd	r24, Y+1	; 0x01
    7400:	9a 81       	ldd	r25, Y+2	; 0x02
    7402:	01 96       	adiw	r24, 0x01	; 1
    7404:	9a 83       	std	Y+2, r25	; 0x02
    7406:	89 83       	std	Y+1, r24	; 0x01
    7408:	71 cf       	rjmp	.-286    	; 0x72ec <main+0x74>
            }
        

            // Write program memory, low byte.        
            else if(val=='c') {												// NOTE: Always use this command before sending high byte.
    740a:	83 36       	cpi	r24, 0x63	; 99
    740c:	49 f4       	brne	.+18     	; 0x7420 <main+0x1a8>
                temp_int=recchar();											// Get low byte for later _FILL_TEMP_WORD.
    740e:	0e 94 49 3b 	call	0x7692	; 0x7692 <recchar>
    7412:	90 e0       	ldi	r25, 0x00	; 0
    7414:	9c 83       	std	Y+4, r25	; 0x04
    7416:	8b 83       	std	Y+3, r24	; 0x03
                sendchar('\r');												// Send OK back.
    7418:	8d e0       	ldi	r24, 0x0D	; 13
    741a:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    741e:	66 cf       	rjmp	.-308    	; 0x72ec <main+0x74>
            }
            
            
            // Write program memory, high byte.
            else if(val=='C') {
    7420:	83 34       	cpi	r24, 0x43	; 67
    7422:	e9 f4       	brne	.+58     	; 0x745e <main+0x1e6>
                temp_int |= (recchar()<<8); // Get and insert high byte.
    7424:	0e 94 49 3b 	call	0x7692	; 0x7692 <recchar>
    7428:	2b 81       	ldd	r18, Y+3	; 0x03
    742a:	3c 81       	ldd	r19, Y+4	; 0x04
    742c:	38 2b       	or	r19, r24
    742e:	3c 83       	std	Y+4, r19	; 0x04
    7430:	2b 83       	std	Y+3, r18	; 0x03
                _WAIT_FOR_SPM();
    7432:	07 b6       	in	r0, 0x37	; 55
    7434:	00 fc       	sbrc	r0, 0
    7436:	fd cf       	rjmp	.-6      	; 0x7432 <main+0x1ba>
                _FILL_TEMP_WORD( (address << 1), temp_int ); // Convert word-address to byte-address and fill.
    7438:	89 81       	ldd	r24, Y+1	; 0x01
    743a:	9a 81       	ldd	r25, Y+2	; 0x02
    743c:	2b 81       	ldd	r18, Y+3	; 0x03
    743e:	3c 81       	ldd	r19, Y+4	; 0x04
    7440:	fc 01       	movw	r30, r24
    7442:	ee 0f       	add	r30, r30
    7444:	ff 1f       	adc	r31, r31
    7446:	09 01       	movw	r0, r18
    7448:	b0 92 57 00 	sts	0x0057, r11	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    744c:	e8 95       	spm
    744e:	11 24       	eor	r1, r1
                address++; // Auto-advance to next Flash word.
    7450:	01 96       	adiw	r24, 0x01	; 1
    7452:	9a 83       	std	Y+2, r25	; 0x02
    7454:	89 83       	std	Y+1, r24	; 0x01
                sendchar('\r'); // Send OK back.
    7456:	8d e0       	ldi	r24, 0x0D	; 13
    7458:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    745c:	47 cf       	rjmp	.-370    	; 0x72ec <main+0x74>
            }
        
        
            // Write page.       
            else if(val== 'm') {
    745e:	8d 36       	cpi	r24, 0x6D	; 109
    7460:	b9 f4       	brne	.+46     	; 0x7490 <main+0x218>
                if(address >= (APP_END>>1)) {								// Protect bootloader area.
    7462:	89 81       	ldd	r24, Y+1	; 0x01
    7464:	9a 81       	ldd	r25, Y+2	; 0x02
    7466:	81 15       	cp	r24, r1
    7468:	e8 e3       	ldi	r30, 0x38	; 56
    746a:	9e 07       	cpc	r25, r30
    746c:	20 f0       	brcs	.+8      	; 0x7476 <main+0x1fe>
                    sendchar('?');
    746e:	8f e3       	ldi	r24, 0x3F	; 63
    7470:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    7474:	09 c0       	rjmp	.+18     	; 0x7488 <main+0x210>
                } else {
                    _WAIT_FOR_SPM();        
    7476:	07 b6       	in	r0, 0x37	; 55
    7478:	00 fc       	sbrc	r0, 0
    747a:	fd cf       	rjmp	.-6      	; 0x7476 <main+0x1fe>
                    _PAGE_WRITE( address << 1 ); // Convert word-address to byte-address and write.
    747c:	fc 01       	movw	r30, r24
    747e:	ee 0f       	add	r30, r30
    7480:	ff 1f       	adc	r31, r31
    7482:	a0 92 57 00 	sts	0x0057, r10	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7486:	e8 95       	spm
                }

                sendchar('\r'); // Send OK back.
    7488:	8d e0       	ldi	r24, 0x0D	; 13
    748a:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    748e:	2e cf       	rjmp	.-420    	; 0x72ec <main+0x74>
            }
#endif /* REMOVE_FLASH_BYTE_SUPPORT */

#ifndef REMOVE_EEPROM_BYTE_SUPPORT
            // Write EEPROM memory.
            else if (val == 'D') {
    7490:	84 34       	cpi	r24, 0x44	; 68
    7492:	b9 f4       	brne	.+46     	; 0x74c2 <main+0x24a>
                _WAIT_FOR_SPM();        
    7494:	07 b6       	in	r0, 0x37	; 55
    7496:	00 fc       	sbrc	r0, 0
    7498:	fd cf       	rjmp	.-6      	; 0x7494 <main+0x21c>
                EEARL = address; // Setup EEPROM address.
    749a:	89 81       	ldd	r24, Y+1	; 0x01
    749c:	81 bd       	out	0x21, r24	; 33
                EEARH = (address >> 8);
    749e:	8a 81       	ldd	r24, Y+2	; 0x02
    74a0:	82 bd       	out	0x22, r24	; 34
                EEDR = recchar(); // Get byte.
    74a2:	0e 94 49 3b 	call	0x7692	; 0x7692 <recchar>
    74a6:	80 bd       	out	0x20, r24	; 32
                EECR |= (1<<EEMPE); // Write byte.
    74a8:	fa 9a       	sbi	0x1f, 2	; 31
                EECR |= (1<<EEPE);
    74aa:	f9 9a       	sbi	0x1f, 1	; 31
                while (EECR & (1<<EEPE)) // Wait for write operation to finish.
    74ac:	f9 99       	sbic	0x1f, 1	; 31
    74ae:	fe cf       	rjmp	.-4      	; 0x74ac <main+0x234>
                    ;
                    
                address++; // Auto-advance to next EEPROM byte.
    74b0:	89 81       	ldd	r24, Y+1	; 0x01
    74b2:	9a 81       	ldd	r25, Y+2	; 0x02
    74b4:	01 96       	adiw	r24, 0x01	; 1
    74b6:	9a 83       	std	Y+2, r25	; 0x02
    74b8:	89 83       	std	Y+1, r24	; 0x01
                sendchar('\r');// Send OK back.
    74ba:	8d e0       	ldi	r24, 0x0D	; 13
    74bc:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    74c0:	15 cf       	rjmp	.-470    	; 0x72ec <main+0x74>
            }

            
            // Read EEPROM memory.
            else if (val == 'd') {
    74c2:	84 36       	cpi	r24, 0x64	; 100
    74c4:	71 f4       	brne	.+28     	; 0x74e2 <main+0x26a>
                EEARL = address; // Setup EEPROM address.
    74c6:	89 81       	ldd	r24, Y+1	; 0x01
    74c8:	81 bd       	out	0x21, r24	; 33
                EEARH = (address >> 8);
    74ca:	8a 81       	ldd	r24, Y+2	; 0x02
    74cc:	82 bd       	out	0x22, r24	; 34
                EECR |= (1<<EERE); // Read byte...
    74ce:	f8 9a       	sbi	0x1f, 0	; 31
                sendchar(EEDR); // ...and send it back.
    74d0:	80 b5       	in	r24, 0x20	; 32
    74d2:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
                address++; // Auto-advance to next EEPROM byte.
    74d6:	89 81       	ldd	r24, Y+1	; 0x01
    74d8:	9a 81       	ldd	r25, Y+2	; 0x02
    74da:	01 96       	adiw	r24, 0x01	; 1
    74dc:	9a 83       	std	Y+2, r25	; 0x02
    74de:	89 83       	std	Y+1, r24	; 0x01
    74e0:	05 cf       	rjmp	.-502    	; 0x72ec <main+0x74>
            }
#endif /* REMOVE_EEPROM_BYTE_SUPPORT */

#ifndef REMOVE_FUSE_AND_LOCK_BIT_SUPPORT
            // Write lockbits.
            else if(val=='l') {
    74e2:	8c 36       	cpi	r24, 0x6C	; 108
    74e4:	79 f4       	brne	.+30     	; 0x7504 <main+0x28c>
                _WAIT_FOR_SPM();        
    74e6:	07 b6       	in	r0, 0x37	; 55
    74e8:	00 fc       	sbrc	r0, 0
    74ea:	fd cf       	rjmp	.-6      	; 0x74e6 <main+0x26e>
                _SET_LOCK_BITS( recchar() ); // Read and set lock bits.
    74ec:	0e 94 49 3b 	call	0x7692	; 0x7692 <recchar>
    74f0:	e1 e0       	ldi	r30, 0x01	; 1
    74f2:	f0 e0       	ldi	r31, 0x00	; 0
    74f4:	08 2e       	mov	r0, r24
    74f6:	e0 92 57 00 	sts	0x0057, r14	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    74fa:	e8 95       	spm
                sendchar('\r'); // Send OK back.
    74fc:	8d e0       	ldi	r24, 0x0D	; 13
    74fe:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    7502:	f4 ce       	rjmp	.-536    	; 0x72ec <main+0x74>
            }
               

#if defined(_GET_LOCK_BITS)
            // Read lock bits.
            else if(val=='r') {
    7504:	82 37       	cpi	r24, 0x72	; 114
    7506:	51 f4       	brne	.+20     	; 0x751c <main+0x2a4>
                _WAIT_FOR_SPM();        
    7508:	07 b6       	in	r0, 0x37	; 55
    750a:	00 fc       	sbrc	r0, 0
    750c:	fd cf       	rjmp	.-6      	; 0x7508 <main+0x290>
                sendchar( _GET_LOCK_BITS() );
    750e:	f2 01       	movw	r30, r4
    7510:	e0 92 57 00 	sts	0x0057, r14	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7514:	84 91       	lpm	r24, Z
    7516:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    751a:	e8 ce       	rjmp	.-560    	; 0x72ec <main+0x74>
            }


            // Read fuse bits.
            else if(val=='F') {
    751c:	86 34       	cpi	r24, 0x46	; 70
    751e:	51 f4       	brne	.+20     	; 0x7534 <main+0x2bc>
                _WAIT_FOR_SPM();        
    7520:	07 b6       	in	r0, 0x37	; 55
    7522:	00 fc       	sbrc	r0, 0
    7524:	fd cf       	rjmp	.-6      	; 0x7520 <main+0x2a8>
                sendchar( _GET_LOW_FUSES() );
    7526:	f8 01       	movw	r30, r16
    7528:	e0 92 57 00 	sts	0x0057, r14	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    752c:	84 91       	lpm	r24, Z
    752e:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    7532:	dc ce       	rjmp	.-584    	; 0x72ec <main+0x74>
            }


            // Read high fuse bits.
            else if(val=='N') {
    7534:	8e 34       	cpi	r24, 0x4E	; 78
    7536:	51 f4       	brne	.+20     	; 0x754c <main+0x2d4>
                _WAIT_FOR_SPM();        
    7538:	07 b6       	in	r0, 0x37	; 55
    753a:	00 fc       	sbrc	r0, 0
    753c:	fd cf       	rjmp	.-6      	; 0x7538 <main+0x2c0>
                sendchar( _GET_HIGH_FUSES() );
    753e:	f3 01       	movw	r30, r6
    7540:	e0 92 57 00 	sts	0x0057, r14	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7544:	84 91       	lpm	r24, Z
    7546:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    754a:	d0 ce       	rjmp	.-608    	; 0x72ec <main+0x74>
            }


            // Read extended fuse bits.
            else if(val=='Q') {
    754c:	81 35       	cpi	r24, 0x51	; 81
    754e:	51 f4       	brne	.+20     	; 0x7564 <main+0x2ec>
                _WAIT_FOR_SPM();        
    7550:	07 b6       	in	r0, 0x37	; 55
    7552:	00 fc       	sbrc	r0, 0
    7554:	fd cf       	rjmp	.-6      	; 0x7550 <main+0x2d8>
                sendchar( _GET_EXTENDED_FUSES() );
    7556:	f4 01       	movw	r30, r8
    7558:	e0 92 57 00 	sts	0x0057, r14	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    755c:	84 91       	lpm	r24, Z
    755e:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    7562:	c4 ce       	rjmp	.-632    	; 0x72ec <main+0x74>
#endif /* defined(_GET_LOCK_BITS) */
#endif /* REMOVE_FUSE_AND_LOCK_BIT_SUPPORT */

#ifndef REMOVE_AVRPROG_SUPPORT        
            // Enter and leave programming mode.
            else if((val=='P')||(val=='L')) {
    7564:	80 35       	cpi	r24, 0x50	; 80
    7566:	11 f0       	breq	.+4      	; 0x756c <main+0x2f4>
    7568:	8c 34       	cpi	r24, 0x4C	; 76
    756a:	21 f4       	brne	.+8      	; 0x7574 <main+0x2fc>
                sendchar('\r');												// Nothing special to do, just answer OK.
    756c:	8d e0       	ldi	r24, 0x0D	; 13
    756e:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    7572:	bc ce       	rjmp	.-648    	; 0x72ec <main+0x74>
            }
            
            
            // Exit bootloader.
            else if(val=='E') {
    7574:	85 34       	cpi	r24, 0x45	; 69
    7576:	61 f4       	brne	.+24     	; 0x7590 <main+0x318>
                _WAIT_FOR_SPM();        
    7578:	07 b6       	in	r0, 0x37	; 55
    757a:	00 fc       	sbrc	r0, 0
    757c:	fd cf       	rjmp	.-6      	; 0x7578 <main+0x300>
                _ENABLE_RWW_SECTION();
    757e:	d0 92 57 00 	sts	0x0057, r13	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7582:	e8 95       	spm
                sendchar('\r');
    7584:	8d e0       	ldi	r24, 0x0D	; 13
    7586:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
                funcptr();													// Jump to Reset vector 0x0000 in Application Section.
    758a:	f8 01       	movw	r30, r16
    758c:	09 95       	icall
    758e:	ae ce       	rjmp	.-676    	; 0x72ec <main+0x74>
            }

    
            // Get programmer type.        
            else if (val=='p') {
    7590:	80 37       	cpi	r24, 0x70	; 112
    7592:	21 f4       	brne	.+8      	; 0x759c <main+0x324>
                sendchar('S');												// Answer 'SERIAL'.
    7594:	83 e5       	ldi	r24, 0x53	; 83
    7596:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    759a:	a8 ce       	rjmp	.-688    	; 0x72ec <main+0x74>
            }
            
            
            // Return supported device codes.
            else if(val=='t') {
    759c:	84 37       	cpi	r24, 0x74	; 116
    759e:	21 f4       	brne	.+8      	; 0x75a8 <main+0x330>
#if PARTCODE+0 > 0
                sendchar( PARTCODE );										// Supports only this device, of course.
#endif /* PARTCODE */
                sendchar(0);												// Send list terminator.
    75a0:	80 e0       	ldi	r24, 0x00	; 0
    75a2:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    75a6:	a2 ce       	rjmp	.-700    	; 0x72ec <main+0x74>
            }
            
            
            // Set LED, clear LED and set device type.
            else if((val=='x')||(val=='y')||(val=='T')) {
    75a8:	98 e8       	ldi	r25, 0x88	; 136
    75aa:	98 0f       	add	r25, r24
    75ac:	92 30       	cpi	r25, 0x02	; 2
    75ae:	10 f0       	brcs	.+4      	; 0x75b4 <main+0x33c>
    75b0:	84 35       	cpi	r24, 0x54	; 84
    75b2:	31 f4       	brne	.+12     	; 0x75c0 <main+0x348>
                recchar();													// Ignore the command and it's parameter.
    75b4:	0e 94 49 3b 	call	0x7692	; 0x7692 <recchar>
                sendchar('\r');												// Send OK back.
    75b8:	8d e0       	ldi	r24, 0x0D	; 13
    75ba:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    75be:	96 ce       	rjmp	.-724    	; 0x72ec <main+0x74>
            }
#endif /* REMOVE_AVRPROG_SUPPORT */
       
            // Return programmer identifier.
            else if(val=='S') {
    75c0:	83 35       	cpi	r24, 0x53	; 83
    75c2:	b1 f4       	brne	.+44     	; 0x75f0 <main+0x378>
                sendchar('A');												// Return 'AVRBOOT'.
    75c4:	81 e4       	ldi	r24, 0x41	; 65
    75c6:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
                sendchar('V');												// Software identifier (aka programmer signature) is always 7 characters.
    75ca:	86 e5       	ldi	r24, 0x56	; 86
    75cc:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
                sendchar('R');
    75d0:	82 e5       	ldi	r24, 0x52	; 82
    75d2:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
                sendchar('B');
    75d6:	82 e4       	ldi	r24, 0x42	; 66
    75d8:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
                sendchar('O');
    75dc:	8f e4       	ldi	r24, 0x4F	; 79
    75de:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
                sendchar('O');
    75e2:	8f e4       	ldi	r24, 0x4F	; 79
    75e4:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
                sendchar('T');
    75e8:	84 e5       	ldi	r24, 0x54	; 84
    75ea:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    75ee:	7e ce       	rjmp	.-772    	; 0x72ec <main+0x74>
            }
            
            // Return software version.
            else if(val=='V') {
    75f0:	86 35       	cpi	r24, 0x56	; 86
    75f2:	39 f4       	brne	.+14     	; 0x7602 <main+0x38a>
                sendchar('1');
    75f4:	81 e3       	ldi	r24, 0x31	; 49
    75f6:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
                sendchar('5');
    75fa:	85 e3       	ldi	r24, 0x35	; 53
    75fc:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    7600:	75 ce       	rjmp	.-790    	; 0x72ec <main+0x74>
            }        

            // Return signature bytes.
            else if(val=='s') {	
    7602:	83 37       	cpi	r24, 0x73	; 115
    7604:	51 f4       	brne	.+20     	; 0x761a <main+0x3a2>
                sendchar(SIGNATURE_BYTE_3);
    7606:	86 e1       	ldi	r24, 0x16	; 22
    7608:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
                sendchar(SIGNATURE_BYTE_2);
    760c:	85 e9       	ldi	r24, 0x95	; 149
    760e:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
                sendchar(SIGNATURE_BYTE_1);
    7612:	8e e1       	ldi	r24, 0x1E	; 30
    7614:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    7618:	69 ce       	rjmp	.-814    	; 0x72ec <main+0x74>
            }       

            // The last command to accept is ESC (synchronization).
            else if(val!=0x1b) {											// If not ESC, then it is unrecognized...
    761a:	8b 31       	cpi	r24, 0x1B	; 27
    761c:	09 f4       	brne	.+2      	; 0x7620 <main+0x3a8>
    761e:	66 ce       	rjmp	.-820    	; 0x72ec <main+0x74>
                sendchar('?');
    7620:	8f e3       	ldi	r24, 0x3F	; 63
    7622:	0e 94 3c 3b 	call	0x7678	; 0x7678 <sendchar>
    7626:	62 ce       	rjmp	.-828    	; 0x72ec <main+0x74>
            }
        } // end: for(;;)
    }
    else {
        _WAIT_FOR_SPM();        
    7628:	07 b6       	in	r0, 0x37	; 55
    762a:	00 fc       	sbrc	r0, 0
    762c:	fd cf       	rjmp	.-6      	; 0x7628 <main+0x3b0>
        _ENABLE_RWW_SECTION();
    762e:	81 e1       	ldi	r24, 0x11	; 17
    7630:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7634:	e8 95       	spm
        funcptr();															// Jump to Reset vector 0x0000 in Application Section.
    7636:	e0 e0       	ldi	r30, 0x00	; 0
    7638:	f0 e0       	ldi	r31, 0x00	; 0
    763a:	09 95       	icall
    }

	return EXIT_SUCCESS;
} // end: main
    763c:	80 e0       	ldi	r24, 0x00	; 0
    763e:	90 e0       	ldi	r25, 0x00	; 0
    7640:	0f 90       	pop	r0
    7642:	0f 90       	pop	r0
    7644:	0f 90       	pop	r0
    7646:	0f 90       	pop	r0
    7648:	df 91       	pop	r29
    764a:	cf 91       	pop	r28
    764c:	1f 91       	pop	r17
    764e:	0f 91       	pop	r16
    7650:	ff 90       	pop	r15
    7652:	ef 90       	pop	r14
    7654:	df 90       	pop	r13
    7656:	cf 90       	pop	r12
    7658:	bf 90       	pop	r11
    765a:	af 90       	pop	r10
    765c:	9f 90       	pop	r9
    765e:	8f 90       	pop	r8
    7660:	7f 90       	pop	r7
    7662:	6f 90       	pop	r6
    7664:	5f 90       	pop	r5
    7666:	4f 90       	pop	r4
    7668:	08 95       	ret

0000766a <initbootuart>:
 *  @details	x
 */
/************************************************************************************************************************************/
void initbootuart(void) {

	BAUD_RATE_LOW_REG = BRREG_VALUE;
    766a:	88 e0       	ldi	r24, 0x08	; 8
    766c:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
	UART_CONTROL_REG = (1 << ENABLE_RECEIVER_BIT) | (1 << ENABLE_TRANSMITTER_BIT); // enable receive and transmit 	
    7670:	88 e1       	ldi	r24, 0x18	; 24
    7672:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    7676:	08 95       	ret

00007678 <sendchar>:
 *  @details	x
 */
/************************************************************************************************************************************/
void sendchar(unsigned char c) {

  UART_DATA_REG = c;														/* prepare transmission									*/
    7678:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
  while (!(UART_STATUS_REG & (1 << TRANSMIT_COMPLETE_BIT)));				/* wait until byte sent									*/
    767c:	e0 ec       	ldi	r30, 0xC0	; 192
    767e:	f0 e0       	ldi	r31, 0x00	; 0
    7680:	80 81       	ld	r24, Z
    7682:	86 ff       	sbrs	r24, 6
    7684:	fd cf       	rjmp	.-6      	; 0x7680 <sendchar+0x8>
  UART_STATUS_REG |= (1 << TRANSMIT_COMPLETE_BIT);							/* delete TXCflag										*/
    7686:	e0 ec       	ldi	r30, 0xC0	; 192
    7688:	f0 e0       	ldi	r31, 0x00	; 0
    768a:	80 81       	ld	r24, Z
    768c:	80 64       	ori	r24, 0x40	; 64
    768e:	80 83       	st	Z, r24
    7690:	08 95       	ret

00007692 <recchar>:
 */
/************************************************************************************************************************************/
unsigned char recchar(void) {

	//Wait for data
	while(!(UART_STATUS_REG & (1 << RECEIVE_COMPLETE_BIT))) {
    7692:	e0 ec       	ldi	r30, 0xC0	; 192
    7694:	f0 e0       	ldi	r31, 0x00	; 0
    7696:	80 81       	ld	r24, Z
    7698:	88 23       	and	r24, r24
    769a:	ec f7       	brge	.-6      	; 0x7696 <recchar+0x4>
	};
  
	return UART_DATA_REG;
    769c:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
}
    76a0:	08 95       	ret

000076a2 <_exit>:
    76a2:	f8 94       	cli

000076a4 <__stop_program>:
    76a4:	ff cf       	rjmp	.-2      	; 0x76a4 <__stop_program>
